# 동기 방식으로 외부 서비스를 호출할 때 외부 서비스 장애가 나면 어떻게 조치할 수 있나요?

## 1. 문제 상황

- 외부 서비스 장애로 응답이 지연되면, 대기 중인 자원(스레드, 커넥션 등)이 서버 내부에 쌓여 전체 시스템 성능에 악영향을 줄 수 있습니다.

## 2. 기본 해결책: 타임아웃 설정

외부 서비스 응답 지연을 방지하기 위한 가장 기본적인 방법은 타임아웃을 설정하는 것입니다.

### 타임아웃 종류
1. **Connection Timeout**: 외부 서비스와 연결을 맺는 데 걸리는 최대 시간 제한
2. **Read Timeout**: 연결 후 응답 데이터를 읽는 데 걸리는 최대 시간 제한
3. **Connection Pool Timeout**: 커넥션 풀에서 커넥션을 획득하는 최대 대기 시간 제한

## 3. 고급 해결책 1: 벌크헤드 패턴 (Bulkhead Pattern)

### 문제 시나리오
```
A 서비스, B 서비스, C 서비스가 HTTP 커넥션 풀을 공유하는 경우
→ A 서비스 장애 발생
→ 풀의 커넥션이 A 서비스 대기로 소진됨
→ B, C 서비스도 커넥션 부족으로 함께 지연됨
```

### 벌크헤드 패턴이란?
- 기능/서비스마다 자원(커넥션 풀, 스레드 풀)을 분리하여 장애 격리를 보장하는 패턴입니다.
- 한 서비스의 장애가 다른 서비스로 전파되지 않도록 방지합니다.

### 적용 방법
- 외부 서비스마다 별도의 HTTP 커넥션 풀을 사용합니다.
- A 서비스에 문제가 발생해도 B, C 서비스는 독립적인 커넥션 풀을 사용하므로 영향을 받지 않습니다.

### 모놀리식에서도 가능한가?
**가능합니다.** 모놀리식 애플리케이션에서도 다음과 같은 방법으로 벌크헤드 패턴을 적용할 수 있습니다:

1. **별도의 스레드 풀 생성**
```java
// A 서비스 전용 스레드 풀
ExecutorService serviceAExecutor = Executors.newFixedThreadPool(10);

// B 서비스 전용 스레드 풀
ExecutorService serviceBExecutor = Executors.newFixedThreadPool(10);

// A 서비스 호출 시
CompletableFuture.supplyAsync(() -> callServiceA(), serviceAExecutor);

// B 서비스 호출 시
CompletableFuture.supplyAsync(() -> callServiceB(), serviceBExecutor);
```

2. **별도의 HTTP 클라이언트 커넥션 풀 설정**
```java
// A 서비스용 HTTP 클라이언트 (독립적인 커넥션 풀)
RestTemplate restTemplateA = new RestTemplate(
    new HttpComponentsClientHttpRequestFactory(
        HttpClients.custom()
            .setMaxConnTotal(20)
            .setMaxConnPerRoute(10)
            .build()
    )
);

// B 서비스용 HTTP 클라이언트 (별도의 커넥션 풀)
RestTemplate restTemplateB = new RestTemplate(
    new HttpComponentsClientHttpRequestFactory(
        HttpClients.custom()
            .setMaxConnTotal(20)
            .setMaxConnPerRoute(10)
            .build()
    )
);
```

**핵심**: 모놀리식에서 Tomcat의 HTTP 요청 스레드 풀은 공유되지만, **외부 서비스 호출을 위한 자원(스레드 풀, 커넥션 풀)은 분리**할 수 있습니다. 이렇게 하면 A 서비스 호출이 지연되어도 B 서비스 호출은 독립적인 자원을 사용하므로 영향을 받지 않습니다.

## 4. 고급 해결책 2: 서킷 브레이커 패턴 (Circuit Breaker Pattern)

### 문제 상황
- 외부 서비스 장애가 지속되는데도 계속 요청을 보내면 불필요한 응답 시간 증가와 처리량 감소가 발생합니다.

### 서킷 브레이커란?
- 오류가 일정 임계값 이상 지속되면 일정 시간 동안 외부 서비스 호출을 차단하는 패턴입니다.
- 빠른 실패(Fail-Fast)를 통해 불필요한 대기 시간을 제거하고 시스템 자원을 보호합니다.

### 서킷 브레이커 상태
1. **Closed (정상)**: 모든 요청이 정상적으로 외부 서비스로 전달됨
2. **Open (차단)**: 오류 임계값 초과 시 모든 요청을 즉시 실패 처리
3. **Half-Open (반개방)**: 일정 시간 후 일부 요청을 허용하여 서비스 복구 여부 확인

## 5. 종합 해결 전략

| 패턴 | 목적 | 효과 |
|------|------|------|
| **타임아웃** | 무한 대기 방지 | 응답 지연 시간 제한 |
| **벌크헤드** | 자원 격리 | 장애 전파 차단 |
| **서킷 브레이커** | 빠른 실패 | 불필요한 호출 차단 |

> **참고**: Spring Cloud Netflix Hystrix, Resilience4j 같은 라이브러리를 사용하여 이러한 패턴들을 쉽게 구현할 수 있습니다.